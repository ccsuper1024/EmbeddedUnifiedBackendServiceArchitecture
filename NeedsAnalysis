嵌入式统一后端服务架构

实现一个可以在树莓派5B上运行的通用后端引擎
1、 要求能够解析处理TCP、UDP、sip、RTP、rtcp、rtsp，Mqtt协议
2、 要求使用lua + C++语言。用lua实现业务逻辑，用C++实现底层协议处理
3、 要求引擎具有高度的可扩展性，能够方便地添加新的协议处理模块和应用层服务
4、 使用cmake作为构建工具，使用单进程+多线程服务模型，IO模型采用非阻塞IO+Reactor模式
5、 我希望能统一所有协议的处理接口，方便业务逻辑层的开发，把不同协议的处理逻辑封装起来，业务逻辑层只需要调用统一的接口即可
    把不同的网络事件统一抽象为事件，业务逻辑层只需要注册事件回调即可
6、 利用好lua的能力，实现配置的热更新，动态逻辑加载，vm等功能。lua不关心底层的网络事件处理，只需要处理好业务逻辑即可
7、 利用好C++高性能的特点，实现底层的协议处理，包括网络IO、协议解析、协议打包，线程池，无锁队列，TimerId，eventId,signalId等
8、程序与外部交互采用protobuf协议或者json协议
9、 要支持10 万连接级。由于嵌入式设备的资源有限并且连接数高，我希望能够设计一个高效的任务队列。每个worker线程都有一个独立的任务队列，用于处理来自不同连接的请求。
    ，事件触发后，将请求放入对应的任务队列中，等待worker线程处理。如果是tcp的消息则连接绑定Worker，如果是UDP的则实现一个UDP Session表来支持会话迁移，负载均衡
以及更复杂的状态管理
10 、要求使用git版本管理，使用googletest进行单元测试，使用spdlog作为日志库
11、 每一个阶段完成后必须使用回测脚本回测当前程序（构建并运行全部测试），并将本阶段相关改动使用git提交并推送到 git@github.com:ccsuper1024/EmbeddedUnifiedBackendServiceArchitecture.git
12、 要求自身具备日志记录功能，能够记录关键事件和错误信息，方便开发人员定位和解决问题
13、 要求能够高性能的处理定时任务，磁盘任务。
14、 天然能够连接redis，mysql，postsql，kafka
5、 要求引擎具有良好的性能和稳定性
6、 要求引擎具有良好的文档和注释，方便开发人员使用和维护
7、 要求引擎具有良好的测试用例，确保代码质量和功能稳定性
8、 要求引擎具有良好的日志记录和错误处理机制，方便开发人员定位和解决问题
9、 要求引擎具有良好的线程安全机制，确保在多线程环境下的稳定运行
10、要求引擎具有良好的内存管理机制，避免内存泄漏和溢出问题
11、要求引擎具有良好的性能优化机制，能够在树莓派5B上高效运行
12、要求引擎具有良好的可维护性和可升级性，能够方便地进行功能扩展和维护
13、 要求引擎具有良好的可移植性，能够在不同的操作系统和硬件平台上运行
14、 要求引擎具有良好的可配置性，能够根据不同的需求进行定制和配置
15、 要求引擎具有良好的可扩展性，能够方便地添加新的功能模块和服务
16、 要求引擎具有良好的可维护性和可升级性，能够方便地进行功能扩展和维护


系统架构：
一、全系统数据流总图（TCP + UDP + Lua + Disk）
                                   ┌──────────────────────┐
                                   │       主线程         │
                                   │  listen / 初始化资源 │
                                   └─────────┬────────────┘
                                             │
                    ┌────────────────────────┼────────────────────────┐
                    │                        │                        │
             TCP IO线程组               UDP IO线程组             定时器线程
           (epoll + recv/send)      (epoll + recvfrom)         (超时/周期任务)
                    │                        │
        ┌───────────┼───────────┐            │
        │           │           │            │
   TCP Conn表   Send队列    Task投递        │
        │           │           │            │
        │           │           │            │
        ▼           │           ▼            ▼
  TCP任务队列 ──────┘     UDP分类器     定时任务投递
  (按Worker分片)             │
                            │
         ┌──────────────────┼──────────────────┐
         │                  │                  │
     信令/控制           自定义协议          RTP流
      (进Worker)          (进Worker)        (高速路径)
         │                  │                  │
         └──────────┬───────┴──────────┐       │
                    │                  │       │
                    ▼                  ▼       │
               Worker线程池 (×N)      │       │
             (每线程1个Lua VM)         │       │
                    │                  │       │
   ┌────────────────┼──────────────────┼───────┘
   │                │                  │
   │                │                  │
   │                │                  │
网络回发任务队列   磁盘任务队列      RTP内存环形缓冲
(Worker→IO线程)    (Worker→Disk线程)   (IO线程写入)
   │                │                  │
   ▼                ▼                  ▼
TCP/UDP IO线程     Disk IO线程池      Disk IO线程池
(send/sendto)      (read/write)       (批量写录制)
   │                │
   │                │
   ▼                ▼
 客户端            磁盘系统
                ┌──────────────┐
                │ 日志文件      │
                │ HTTP文件      │
                │ 录制文件      │
                │ 状态持久化    │
                └──────────────┘

二、TCP 完整路径（逐步流转）
客户端
  ↓
[TCP IO线程]
  recv()
  ↓
解析协议头/拆包
  ↓
封装 TcpTask
  ↓
投递 → Worker队列[hash(conn_id)]
  ↓
[Worker线程]
  Lua处理业务
  ↓
生成响应数据
  ↓
投递 → IO线程Send队列
  ↓
[TCP IO线程]
  send()
  ↓
客户端


关键点：

一个 TCP 连接固定归属一个 IO线程

一个连接的数据固定进入同一个 Worker

无锁 + cache命中率高

三、UDP 完整路径（分三类）
1）信令 / 控制消息
recvfrom()
  ↓
获取 src_ip:port
  ↓
hash → Worker队列
  ↓
Worker + Lua处理
  ↓
生成响应
  ↓
sendto任务 → IO线程
  ↓
sendto()

2）自定义协议（游戏/状态同步）

与信令相同路径：

UDP IO线程
  ↓
hash(src)
  ↓
Worker
  ↓
Lua逻辑

3）RTP（高速路径，关键）
UDP IO线程
  recvfrom()
  ↓
解析SSRC
  ↓
查session表
  ↓
写入内存环形缓冲
  ↓
Disk线程批量写文件


不经过：

Worker

Lua

任务队列

这是低延迟核心。

四、Worker线程内部结构

每个 Worker线程包含：

while(true):
    task = queue.pop()

    switch(task.type):

        TCP_DATA:
            lua_on_tcp_message()

        UDP_SIGNAL:
            lua_on_udp_signal()

        TIMER:
            lua_on_timer()

        DISK_CALLBACK:
            lua_on_disk_done()


每个 Worker：

1个线程
1个Lua VM
1个任务队列


无需锁。

五、磁盘 IO 路径（完整）
读文件（HTTP）
Worker解析HTTP请求
  ↓
生成 DiskTask(READ)
  ↓
Disk队列
  ↓
Disk线程 read()
  ↓
回调 Worker
  ↓
Worker生成 SendTask
  ↓
IO线程 send

写日志
Worker生成 LogTask
  ↓
Log队列
  ↓
Log线程
  批量 write()
  每100ms flush

RTP录制
UDP IO线程
  ↓
写入 ring buffer
  ↓
Disk线程
  每1MB批量写

Lua状态持久化
Lua修改状态
  ↓
Worker生成 DiskTask(APPEND)
  ↓
Disk线程写入
  ↓
完成回调 Worker

六、各线程“绝对不能做的事”
IO线程禁止：

Lua

磁盘IO

数据库

复杂计算

Worker线程避免：

阻塞磁盘IO

长时间计算

Disk线程允许：

阻塞

read/write

fsync

七、线程数量参考（10万连接级）

假设 16核：

主线程        1
TCP IO线程    4
UDP IO线程    2
Worker线程    8
Disk线程      3
Log线程       1
Timer线程     1

八、这是一个什么级别的架构？

这套模型本质上已经接近：

Nginx（网络模型）

Redis（单线程IO+Worker思路）

音视频SFU（RTP路径）

游戏网关（UDP分发）

的融合体。

是典型的：

高并发通用网络服务器底座

九、下一步可以继续深入的“核心模块”

建议按这个顺序继续设计（越往下越接近生产级）：

1）连接对象 Conn 结构体设计
2）任务队列的无锁实现（MPSC ring buffer）
3）Lua VM 管理策略
4）内存池设计（避免频繁malloc）
5）session表设计（TCP/UDP统一）
6）背压机制（防止队列爆炸）
