嵌入式统一后端服务架构设计

一、背景与目标

1. 背景
本项目旨在在树莓派5B 等嵌入式环境上实现一套通用、高性能、高扩展性的网络后端引擎，统一多种协议的处理方式，为上层 Lua 业务逻辑提供一致的事件和接口抽象。

2. 目标
- 支持 TCP、UDP、SIP、RTP、RTCP、RTSP、MQTT 等多种协议
- 使用 Lua + C++，Lua 负责业务逻辑，C++ 负责底层网络与协议处理
- 单进程 + 多线程模型，IO 使用非阻塞 IO + Reactor 模式
- 支持 10 万连接级并发
- 统一所有协议的处理接口和事件模型，业务层仅面向统一接口开发
- 支持配置热更新、动态逻辑加载和多 Lua VM 管理
- 提供完善的日志、测试、错误处理与监控能力
- 在树莓派5B 上保持高性能和稳定性

3. 约束条件
- 硬件资源有限（CPU、内存、磁盘 IO 能力受限）
- 需要高度可扩展和可移植的设计，支持不同 OS 与硬件平台
- 代码需具备良好的可读性、可维护性与单元测试覆盖

二、总体架构概览

1. 关键角色
- 主线程：负责进程启动、配置加载、监听端口和各类资源初始化
- TCP IO 线程组：基于 epoll 的非阻塞 IO，负责 TCP 收发与连接管理
- UDP IO 线程组：基于 epoll 的非阻塞 IO，负责 UDP 收包与分类
- Worker 线程池：每个线程绑定一个 Lua VM，执行业务逻辑与任务调度
- 磁盘 IO 线程/线程池：负责日志写入、HTTP 文件读取、录制文件写入、状态持久化等
- 定时器线程：管理超时和周期性任务，向 Worker 投递定时任务事件
- 日志线程：接收日志任务，批量写入磁盘

2. 分层结构
- 网络 IO 层：负责 socket 管理、accept、收发、连接维护
- 协议解析与会话层：负责各类协议的解析、打包和 Session 管理
- 任务队列与调度层：基于无锁队列的任务分发与负载均衡
- 业务脚本层（Lua）：处理具体业务逻辑、路由、状态管理
- 存储与消息层：Redis、MySQL、PostgreSQL、Kafka 等外部系统访问
- 日志与监控层：结构化日志、指标采集、错误告警
- 配置与管理层：配置加载、热更新、运行时控制接口

三、模块划分

1. 网络 IO 模块
- 统一抽象 TCP/UDP 套接字操作，封装 epoll 注册、事件回调
- 对每个 TCP 连接维护 Conn 对象，记录状态、缓冲区和绑定的 Worker
- UDP 层支持基于 src_ip:port 或 SSRC 的分类
- IO 线程仅负责轻量级工作：网络收发、基础解析和任务投递

2. 协议解析与 Session 模块
- 对 TCP/UDP 流量做协议栈分层：基础传输层 + 应用层协议解析
- 提供可插拔的协议处理接口，便于扩展 SIP、RTSP、MQTT 等
- 设计统一 Session 表（TCP/UDP 统一），支持：
  - TCP 连接会话
  - UDP Session（基于五元组或业务 ID）
  - RTP Session（基于 SSRC）
- 为上层输出统一的事件对象（包含协议类型、会话信息、负载数据）

3. 任务队列与线程池模块
- 采用单进程 + 多线程模型：
  - 若干 IO 线程
  - N 个 Worker 线程
  - M 个磁盘 IO 线程
  - 独立日志线程和定时器线程
- 每个 Worker 拥有独立的无锁任务队列（MPSC ring buffer）：
  - IO 线程将任务投递到对应 Worker 队列
  - Worker 线程从队列中顺序消费任务，保证单线程逻辑简化
- 通过 hash(conn_id) 或 hash(src_ip:port) 将连接/会话固定分配到同一 Worker，保证有序性并减少锁竞争

4. Lua 集成模块
- 每个 Worker 线程维护一个 Lua VM：
  - 避免跨线程共享 Lua 状态，减少锁和竞态
  - Lua VM 负责业务逻辑、路由、状态处理和部分配置驱动
- 提供 C++ 与 Lua 的桥接接口：
  - 网络事件回调：lua_on_tcp_message、lua_on_udp_signal 等
  - 定时任务回调：lua_on_timer
  - 磁盘/外部系统回调：lua_on_disk_done 等
- 支持：
  - 动态加载 Lua 脚本
  - 配置驱动的脚本版本切换
  - 线上热更新（在安全窗口内替换脚本）

5. 磁盘 IO 与存储模块
- 日志写入：
  - Worker 生成 LogTask，写入日志队列
  - 日志线程批量 write，每隔固定时间 flush，降低磁盘压力
- HTTP 文件访问：
  - Worker 解析 HTTP 请求，生成 DiskTask(READ)
  - 磁盘线程 read 完成后回调 Worker，由 Worker 生成 SendTask 返回给 IO 线程
- RTP 录制：
  - UDP IO 线程将 RTP 数据写入内存环形缓冲
  - 磁盘线程按块（如 1MB）批量写录制文件
- 状态持久化：
  - Lua 修改状态时生成 DiskTask(APPEND)
  - 磁盘线程写入持久化文件，完成后回调 Worker

6. 外部服务接入模块
- 统一封装 Redis、MySQL、PostgreSQL、Kafka 等访问接口
- 支持异步请求模式：
  - Worker 发起请求后生成异步任务
  - IO/专用线程负责与外部系统通信
  - 完成后回调到对应 Worker + Lua
- 采用连接池和重连机制，确保稳定性和性能

7. 日志与监控模块
- 基于 spdlog 实现：
  - 统一日志格式（时间、级别、模块、上下文）
  - 支持控制台和文件输出
  - 支持日志等级动态配置
- 指标监控：
  - 连接数、QPS、队列长度、延迟分布、错误率
  - 可通过 HTTP 或其他方式提供状态查询接口

8. 配置与管理模块
- 配置文件定义：
  - 端口、线程数、队列大小、日志级别
  - 各协议模块配置和路由规则
- 支持配置热更新：
  - 主线程或管理线程加载新配置
  - 向各线程广播配置变更事件
  - Worker / IO 线程在安全点应用新配置
- 预留管理接口：
  - 控制模块启停
  - 调整运行参数

四、线程模型与职责划分

1. IO 线程职责
- 负责：
  - accept、recv、send / recvfrom、sendto
  - 基础协议解析（如拆包、识别协议类型）
  - 将任务封装为 Task 对象并投递到 Worker 或磁盘队列
- 明确禁止：
  - 运行 Lua 脚本
  - 阻塞磁盘 IO
  - 数据库/外部系统访问
  - 长时间复杂计算

2. Worker 线程职责
- 负责：
  - 从自身任务队列获取任务
  - 调用 Lua VM 执行业务逻辑
  - 生成网络回发任务、磁盘任务、外部服务任务
- 尽量避免：
  - 阻塞操作（尤其磁盘和网络）
  - 超长时间计算影响队列消费

3. 磁盘与日志线程职责
- 磁盘线程：
  - 专职 read/write/fsync
  - 批量处理 DiskTask，提高吞吐
- 日志线程：
  - 批量写日志，平衡实时性与性能

4. 线程数量示例（16 核参考）
- 主线程：1
- TCP IO 线程：4
- UDP IO 线程：2
- Worker 线程：8
- 磁盘线程：3
- 日志线程：1
- 定时器线程：1

五、数据流设计

1. TCP 数据流
- 客户端 → TCP IO 线程：
  - recv 数据，按协议拆包
  - 封装为 TcpTask，携带 conn_id 和 payload
- IO → Worker：
  - 按 hash(conn_id) 投递到对应 Worker 队列
- Worker：
  - 调用 Lua 业务逻辑处理
  - 生成响应数据，封装为 SendTask
- Worker → IO：
  - IO 线程从发送队列取出 SendTask，执行 send
- IO → 客户端：
  - 客户端收到响应

2. UDP 数据流
- 信令 / 控制 / 自定义协议：
  - UDP IO 线程 recvfrom
  - 基于 src_ip:port 或业务规则计算 hash，投递到 Worker
  - Worker + Lua 处理，生成响应
  - 通过 IO 线程 sendto 返回
- RTP 高速路径：
  - UDP IO 线程 recvfrom
  - 解析 SSRC，查找 session
  - 写入内存环形缓冲
  - 磁盘线程按块写入录制文件
  - 不经过 Worker 和 Lua，保证最低延迟

3. 磁盘 IO 流
- HTTP 文件读取、日志、录制、状态持久化均通过 DiskTask/LogTask 形式实现
- 所有磁盘操作在专用线程中完成，避免阻塞业务线程

六、扩展性与可配置性设计

1. 协议扩展
- 提供统一的协议插件接口：
  - 注册协议 ID、解析函数、打包函数
  - 注册对应的 Lua 回调或 C++ 回调
- 新增协议仅需：
  - 增加协议解析器和打包器
  - 补充配置与 Lua 逻辑

2. 业务扩展
- Lua 层通过配置驱动：
  - 新业务模块以 Lua 脚本形式引入
  - 通过配置映射事件类型到 Lua 处理函数
- C++ 层保持稳定接口，降低改动成本

3. 部署与可移植性
- 使用 CMake 管理构建：
  - 适配不同平台编译选项
  - 隔离平台相关代码
- 网络、线程、计时等底层细节通过抽象层封装，方便移植到不同 OS/硬件

七、性能与可靠性设计

1. 性能策略
- 无锁队列（MPSC ring buffer）减少锁竞争
- 内存池管理避免频繁 malloc/free
- 固定连接归属的 Worker，提升 cache 命中率
- IO、Worker、磁盘职责清晰，减少上下文切换
- 批量写日志和录制文件，减少磁盘压力

2. 可靠性策略
- 健壮的错误处理：
  - 协议解析异常、网络异常、磁盘错误统一上报
  - 日志记录关键错误和状态
- 背压机制：
  - 监控任务队列长度，必要时丢弃低优先级任务或限制新请求
- 超时与重试：
  - 对外部系统访问设置超时和重试策略

八、测试与文档策略

1. 测试
- 使用 googletest 进行单元测试：
  - Conn 结构体与任务队列
  - 协议解析与打包
  - Lua 桥接接口
  - 磁盘任务与回调流程
- 引入压力测试和长稳测试场景，验证 10 万连接级目标

2. 文档
- 设计文档：
  - 本系统架构设计文档
  - 各模块详细设计文档
- 开发文档：
  - 编译、部署、配置说明
  - Lua 开发指南和 API 说明
- 运维文档：
  - 日志与监控指标说明
  - 常见故障分析与排查流程

九、需求映射关系（概览）

- 需求 1（多协议解析）：由网络 IO 模块 + 协议解析模块 + Session 表共同实现
- 需求 2（Lua + C++）：由 Lua 集成模块 + C++ 网络/协议层实现
- 需求 3（可扩展性）：通过协议插件化、统一事件接口和模块化设计满足
- 需求 4（CMake + Reactor）：由构建系统与 IO 线程 + epoll + Reactor 模型实现
- 需求 5（统一接口）：通过统一事件模型和 Lua 回调接口实现
- 需求 6（热更新）：通过配置与 Lua 脚本动态加载机制实现
- 需求 7（高性能 C++）：由 C++ 实现底层 IO、协议、线程池、无锁队列等
- 需求 8（外部交互协议）：在边界层提供 Protobuf/JSON 封装
- 需求 9（10 万连接级 + 任务队列）：通过多 IO + 多 Worker + 无锁任务队列设计实现
- 需求 10（git/googletest/spdlog）：纳入工程实践与基础设施
- 需求 11～16（日志、测试、线程安全、内存管理、性能优化、可维护性/可移植性/可配置性/可扩展性）：由上述模块化设计、线程模型、内存策略、日志与监控、测试与文档体系综合保障

